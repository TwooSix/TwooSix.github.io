<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Blog"><meta name="author" content="TwoSix"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://registry.npmmirror.com" crossorigin><link rel="canonical" href="https://twosix.page/2023/05/08/【rust-学习记录】10-泛型、trait与生命周期/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="无无聊聊，简简单单"><meta property="og:type" content="article"><meta property="og:title" content="【Rust 学习记录】10. 泛型、trait与生命周期"><meta property="og:url" content="https://twosix.page/2023/05/08/%E3%80%90Rust-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%9110-%E6%B3%9B%E5%9E%8B%E3%80%81trait%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/index.html"><meta property="og:site_name" content="TwoSix的小木屋"><meta property="og:description" content="无无聊聊，简简单单"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://twosix.page/images/image.png"><meta property="article:published_time" content="2023-05-08T13:17:12.000Z"><meta property="article:modified_time" content="2024-07-04T15:52:28.391Z"><meta property="article:author" content="TwoSix"><meta property="article:tag" content="Rust"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://twosix.page/images/image.png"><link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico"><meta name="theme-color" content="#9d5da2"><link rel="shortcut icon" href="/images/logo.ico"><title>【Rust 学习记录】10. 泛型、trait与生命周期 | TwoSix的小木屋</title><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css"><script data-swup-reload-script defer src="https://umami.2626666.xyz/script.js" data-website-id="1febf3b2-6f24-4ac8-a6ff-458478feafb9"></script><meta name="baidu-site-verification" content="codeva-t9TDxWNwbp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css"><script id="hexo-configurations">window.config={hostname:"twosix.page",root:"/",language:"zh-CN",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!0,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#9d5da2",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!1,custom_message:null},open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/background.webp",dark:"/images/background.webp"},title:"TwoSix的小木屋",subtitle:{text:["Hello World!"],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!0,style:"default",links:{github:"https://github.com/TwooSix",instagram:null,zhihu:null,twitter:null,email:null,"fa-solid fa-envelope":"mailto:ljj2288@gmail.com"},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"9.3.0"}},version:"2.8.2",navbar:{auto_hide:!0,color:{left:"#4f35a2",right:"#cbd0f6",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},"时间线":{path:"/archives",icon:"fa-regular fa-archive"},"追番列表":{path:"/bangumi",icon:"fa-regular fa-tv"},About:{path:"/about",icon:"fa-regular fa-user"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"info",announcement:null,show_on_mobile:!0,links:null},article_date_format:"auto",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/11/26 18:00:00"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/sharp-solid.min.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="TwoSix的小木屋" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">TwoSix的小木屋</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-regular fa-archive fa-fw"></i> 时间线</a></li><li class="navbar-item"><a href="/bangumi"><i class="fa-regular fa-tv fa-fw"></i> 追番列表</a></li><li class="navbar-item"><a href="/about"><i class="fa-regular fa-user fa-fw"></i> 关于</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>时间线 </span><i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/bangumi"><span>追番列表 </span><i class="fa-regular fa-tv fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/about"><span>关于 </span><i class="fa-regular fa-user fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">4</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">2</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">【Rust 学习记录】10. 泛型、trait与生命周期</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/logo.webp"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">TwoSix</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2023-05-08 21:17:12</span> <span class="mobile">2023-05-08 21:17:12</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-07-04 23:52:28</span> <span class="mobile">2024-07-04 23:52:28</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/%E7%BC%96%E7%A8%8B-%E8%AF%AD%E8%A8%80/">编程/语言</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/Rust/">Rust</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>7k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>29 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型是一种具体类型或者其他属性的抽象替代，通常用来减少代码的重复，接下来将从泛型的几个实际应用场景开始介绍泛型</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="在函数定义中使用"><a href="#在函数定义中使用" class="headerlink" title="在函数定义中使用"></a>在函数定义中使用</h3><p>现在假设我们要写一个寻找数组最大值的功能，我要怎么实现既能从字符数组里查找最大值，又能从整数数组里查找最大值？定义两个函数分别查找的话难免重复性有点高，这时候就需要使用泛型。</p><div class="code-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;&lt;T&gt;) <span class="punctuation">-&gt;</span> T&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以上代码定义了一个寻找数组最大值的泛型函数，首先</p><ol><li>需要声明一个泛型名称<code>T</code>，放置在函数名和参数的圆括号之间，用尖括号括起来，<code>largest(list: &amp;&lt;T&gt;)</code></li><li>后续的类型声明，就都可以用<code>T</code>来代替了</li></ol><p>但以上代码暂时无法提示，rust-analyzer会报错<code>binary operation &#39;&gt;&#39; cannoy be applied to type &#39;T&#39;</code>，也就是说<code>&gt;</code>运算符不能直接用于泛型参数，这个问题会在后续解决，现在重点先放在泛型的应用场景。</p><h3 id="在结构体定义中使用"><a href="#在结构体定义中使用" class="headerlink" title="在结构体定义中使用"></a>在结构体定义中使用</h3><div class="code-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point&#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point&#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>结构体中，泛型名称声明在结构体名字后面，<code>Point</code>，这段代码是可以编译通过的。</p><p>但注意，当你使用两种类型的变量创建泛型结构体时，就无法编译通过了。</p><div class="code-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point&#123; x: <span class="number">5</span>, y: <span class="number">10.0</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>报错：<code>expected integer, found floating-point number</code></p><p>这是因为，当你向泛型<code>T</code>传入第一次传入值5的时候，编译器会自动为<code>T</code>赋值为和5相同的类型，即整型。也就是说，<strong>泛型并不是代表能接受所有类型的变量，而是编译器自动帮你识别为第一次接收到的变量类型</strong>。</p><p>但如果我们就是可能传入两个类型呢？解决这个问题也简单，我们声明两个泛型，存储两个类型即可</p><div class="code-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point&#123; x: <span class="number">5</span>, y: <span class="number">10.0</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>声明多个泛型只需要在尖括号内用逗号隔开即可。</p><p>这段代码里，我们声明了两个泛型名称<code>T, U</code>，这时候我们分别为类型为<code>T, U</code>的变量<code>x, y</code>传入5，10.0，对应的，此时<code>T</code>代表整型，<code>U</code>代表浮点型</p><h3 id="在方法定义中使用"><a href="#在方法定义中使用" class="headerlink" title="在方法定义中使用"></a>在方法定义中使用</h3><p>有了泛型的结构体，自然也就能有泛型的结构体方法了</p><div class="code-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>, other: &amp;Point&lt;T&gt;) <span class="punctuation">-&gt;</span> &amp;T&#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意，这里我们使用两次，也就是说，我们需要在<code>impl</code>后声明一次泛型名称，再在后续指定泛型。</p><p>这是因为，在泛型结构体里我们可以单独的为某个类型实现方法，而不是一定要所有类型都使用同一个方法，例如：</p><div class="code-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>, other: &amp;Point&lt;<span class="type">f32</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="type">f32</span>&#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这段代码里，我们就相当于单独的为<code>f32</code>类型设定了方法x，只有当<code>T</code>的类型为<code>f32</code>时可以使用这个方法。这种写法可以很经常的被用于处理不同类型的不同情况。</p><p>因此，我们需要先声明以下泛型名字，才能确保编译器知道你后面的尖括号到底是泛型还是具体类型。</p><p>当然，我们的方法也可以和函数一样，再次声明自己的泛型名称</p><div class="code-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> &lt;T, U&gt;Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other:Point&lt;V, W&gt;)<span class="punctuation">-&gt;</span>Point&lt;T, W&gt;&#123;</span><br><span class="line">        Point&#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码里，我们在<code>mixup</code>函数里新定义了<code>V, W</code>两个泛型，用来接收可能不同类型的其他<code>Point</code>实例，并把两个实例的类型进行混合后，作为新的<code>Point</code>返回</p><h3 id="在枚举类型定义中使用"><a href="#在枚举类型定义中使用" class="headerlink" title="在枚举类型定义中使用"></a>在枚举类型定义中使用</h3><p>在之前章节的学习里，我们就知道了<code>Result</code>和<code>Option</code>枚举。其中<code>Option</code>就是典型的单泛型枚举，<code>Result</code>就是典型的包含两个泛型的枚举</p><div class="code-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt;&#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="泛型的性能"><a href="#泛型的性能" class="headerlink" title="泛型的性能"></a>泛型的性能</h2><p>可能有人会担心，泛型会不会和Python一样，使得程序有运行时的性能影响？</p><p>实际上是不会的，Rust的泛型和c++的auto差不多，会在编译器就静态固定好对应的类型，因此不会产生运行时的损耗，只会在编译期有性能损耗</p><h1 id="trait：定义共享行为"><a href="#trait：定义共享行为" class="headerlink" title="trait：定义共享行为"></a>trait：定义共享行为</h1><p><code>trait</code>（特征？）是用来描述一个类型的功能，可以用来和多个类型共享。例如说求和，每个类型的求和都不尽相同的时候，你可以定义一个trait名为sum，然后再分别为不同的类型实现sum</p><p><code>trait</code>可能和其他语言的<code>interface</code>功能类似，但也不完全相同</p><h2 id="定义trait"><a href="#定义trait" class="headerlink" title="定义trait"></a>定义trait</h2><p>现在假设我们有两个结构体类型，一个是文章（Article），一个是推特（Tweet），我们需要同时为这两个文字内容主体生成摘要，于是我们就可以定义一个Summary的trait，来规定一个适用于所有类型的生成摘要的接口。</p><p>接下来我们新建一个库文件<code>lib.rs</code>，然后定义一个trait</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这段代码里，首先我们定义了一个公有的trait <code>Summary</code>，并规定了trait里有一个函数<code>summarize</code>，在 trait 里，称作<strong>签名</strong>，它传入类型实例自己，返回<code>String</code>，但这里我们省略了函数的具体实现，具体实现交由不同的类型按照自己的规则来进行实现。</p><p>当然一个trait里可以有多个签名，这里只定义了一个。</p><h2 id="实现trait"><a href="#实现trait" class="headerlink" title="实现trait"></a>实现trait</h2><p>接下来，我们就需要给文章和推特两个结构体类型实现一下用于提取摘要的trait</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pub struct Article&#123;</span><br><span class="line">    pub title: String,</span><br><span class="line">    pub location: String,</span><br><span class="line">    pub author: String,</span><br><span class="line">    pub content: String,</span><br><span class="line">&#125;</span><br><span class="line">impl Summary for Article &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.title, self.author, self.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet&#123;</span><br><span class="line">    pub username: String,</span><br><span class="line">    pub content: String,</span><br><span class="line">&#125;</span><br><span class="line">impl Summary for Tweet &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;&#123;&#125;: &#123;&#125;&quot;, self.username, self.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码，我们定义了两个公有的结构体<code>Article</code>和<code>Tweet</code>，并使用<code>impl Summary for xxx</code>语句，声明为结构体实现<code>Summary</code>这个trait，然后再在<code>impl</code>块里，实现trait内的签名<code>summarize</code>，这时候就可以根据实际情况来返回不同的摘要了。代码中我们是使用<code>format!</code>格式化返回不同的内容。</p><p>实现后，我们就可以在具体的实例里使用这个trait了</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use test10::&#123;Tweet, Summary&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let test = Tweet&#123;</span><br><span class="line">        username: String::from(&quot;TwoSix&quot;),</span><br><span class="line">        content: String::from(&quot;Hello, world!&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;A new tweet: &#123;&#125;&quot;, test.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意看我们的use代码<code>use test10::&#123;Tweet, Summary&#125;</code>，这里我们同时引进<code>Tweet</code>类型和<code>Summary</code>这个trait，才能让<code>Tweet</code>实例使用trait对应的成员函数，否则会编译报错，不信你可以试试。（test10是我自己创建的根目录名字）</p><p>这一点和其他语言都不一样，有点让人迷惑，实现了trait之后难道不是相当于结构体的成员函数了吗？为什么成员还需要额外引进才能使用？</p><p>这是因为trait提供了相当的灵活性，以至于编译器并不好自动检查怎么使用，例如以下场景：我们实现了两个trait，Summary1 和 Summary2，并且这两个trait里都有一个签名叫做 summarize ，然后我们还在Tweet 结构体里同时实现了这两个 trait</p><p>是的，Rust允许这种场景的存在，那你说这时候调用 summarize时，应该调用的是Summary1 还是 Summary2？因此，必须显示引入，才能正常使用。</p><p>使用就如此，那实现自然也是，如果你想实现别人定义的 trait，那你就需要把别人的 trait 显示引入当前的作用域，才能实现别人的 trait。</p><h2 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h2><p>前面我们没有在trait内实现<code>summarize</code>签名，交由每个类型自己实现，但实际上我们也可以为其定义一个默认实现。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String&#123;</span><br><span class="line">        String::from(&quot;(Read more...)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里我们在trait的定义内实现了<code>summarize</code>签名，默认返回一个 (Read more…) 的字符串</p><p>然后我们修改一下<code>Article</code>的实现</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pub struct Article&#123;</span><br><span class="line">    pub title: String,</span><br><span class="line">    pub location: String,</span><br><span class="line">    pub author: String,</span><br><span class="line">    pub content: String,</span><br><span class="line">&#125;</span><br><span class="line">impl Summary for Article &#123;&#125;</span><br></pre></td></tr></table></figure></div><p>我们在实现<code>Summary</code>的时候，直接使用空的花括号，没有实现具体的 trait 签名，然后我们再使用看一下效果。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use test10::&#123;Tweet, Article, Summary&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let test_tweet: Tweet = Tweet&#123;</span><br><span class="line">        username: String::from(&quot;TwoSix&quot;),</span><br><span class="line">        content: String::from(&quot;Hello, world!&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    let test_article = Article&#123;</span><br><span class="line">        title: String::from(&quot;Hello&quot;),</span><br><span class="line">        location: String::from(&quot;World&quot;),</span><br><span class="line">        author: String::from(&quot;TwoSix&quot;),</span><br><span class="line">        content: String::from(&quot;This is a test&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;A new article: &#123;&#125;&quot;, test_tweet.summarize());</span><br><span class="line">    println!(&quot;A new tweet: &#123;&#125;&quot;, test_article.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>没有意外，正常的输出 (Read more…)，并且 Tweet 的输出正常，不会受到影响。这个概念也很常见，也就是重载。</p><h2 id="把trait作为参数"><a href="#把trait作为参数" class="headerlink" title="把trait作为参数"></a>把trait作为参数</h2><p>trait 甚至能作为函数的参数传入，见以下示例</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">use test10::&#123;Tweet, Article, Summary&#125;;</span><br><span class="line"></span><br><span class="line">fn summarize(item: impl Summary) -&gt; String&#123;</span><br><span class="line">    item.summarize()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let test_tweet: Tweet = Tweet&#123;</span><br><span class="line">        username: String::from(&quot;TwoSix&quot;),</span><br><span class="line">        content: String::from(&quot;Hello, world!&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    let test_article = Article&#123;</span><br><span class="line">        title: String::from(&quot;Hello&quot;),</span><br><span class="line">        location: String::from(&quot;World&quot;),</span><br><span class="line">        author: String::from(&quot;TwoSix&quot;),</span><br><span class="line">        content: String::from(&quot;This is a test&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;A new article: &#123;&#125;&quot;, summarize(test_tweet));</span><br><span class="line">    println!(&quot;A new tweet: &#123;&#125;&quot;, summarize(test_article));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们定义了一个函数<code>summarize</code>来调用每个实现了 Summary trait 的类型的 summarize 函数。这里的<code>impl Summary</code> 就是指代的所有实现了 Summary trait 的类型。</p><h3 id="trait约束"><a href="#trait约束" class="headerlink" title="trait约束"></a>trait约束</h3><p>以上<code>impl Summary</code>实际上只是一个语法糖，它的完整声明形式称作 triat 约束，写作如下</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn summarize&lt;T: Summary&gt;(item: T) -&gt; String&#123;</span><br><span class="line">    item.summarize()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>意思就是声明了一个泛型<code>T</code>，并使用<code>:Summary</code>对泛型T指代的类型进行了约束，使它只能代表实现了 Summary trait 的类型。</p><p>实际上在函数较复杂的时候，triat 约束要比之前的语法糖要好用</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn summarize&lt;T: Summary&gt;(item1: T, item2:T, item3: T) -&gt; String&#123;</span><br><span class="line">    item1.summarize();</span><br><span class="line">    item2.summarize();</span><br><span class="line">    item3.summarize()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn summarize(item1: impl Summary, item2:impl Summary, item3: impl Summary) -&gt; String&#123;</span><br><span class="line">    item1.summarize();</span><br><span class="line">    item2.summarize();</span><br><span class="line">    item3.summarize()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对比一下这两种写法，是不是在复杂的情况，反而 triat 约束更简洁了一些？</p><h3 id="多个trait约束"><a href="#多个trait约束" class="headerlink" title="多个trait约束"></a>多个trait约束</h3><p>如果我想让泛型 T 指代实现了多个 triat 的类型怎么办？使用 + 法可以解决这个问题</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn summarize&lt;T: Summary + Display&gt;(item: T) -&gt; String&#123;</span><br><span class="line">    item.summarize()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里就表示，传入的 item 必须是同时实现了 Summary trait 和标准库的 Display trait 的类型。</p><h3 id="简化trait约束"><a href="#简化trait约束" class="headerlink" title="简化trait约束"></a>简化trait约束</h3><p>当有多个泛型参数，每个泛型参数有多个 trait 约束的时候，会写成这样</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn summarize&lt;T: Summary + Display, U: Summary + Display&gt;(item1: T, item2: U) -&gt; String&#123;</span><br></pre></td></tr></table></figure></div><p>这样就会导致函数定义很长又有很多重复内容，阅读费劲，难以理解，所以 rust 提供了一个 where 从句的方法，提高这种情况下的可读性</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn summarize&lt;T, U&gt;(item1: T, item2: U) -&gt; String</span><br><span class="line">    where T: Summary + Display,</span><br><span class="line">          U: Summary + Display</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></div><p>我们可以在返回值的类型后面，加上一个 where 从句，把每个泛型的 trait 约束换一行之后再定义，就美观多了。</p><h2 id="把trait作为函数返回值类型"><a href="#把trait作为函数返回值类型" class="headerlink" title="把trait作为函数返回值类型"></a>把trait作为函数返回值类型</h2><p>既然能作为函数参数传入，自然也能作为函数返回值进行返回了</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn summarize() -&gt; impl Summary</span><br><span class="line">&#123;</span><br><span class="line">    Tweet&#123;</span><br><span class="line">        username: String::from(&quot;TwoSix&quot;),</span><br><span class="line">        content: String::from(&quot;Hello, world!&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这一段代码则让 summarize 函数固定返回实现了 Summary 的 Tweet 类型，但这种用法似乎感觉没有什么用？没关系，书上说后续讲解闭包等概念的时候，会使用到这种语法。</p><p>需要注意的是，Rust 编译器同样会对 impl Trait 进行静态推理保存，碍于 impl Trait 工作方式的限制，所以你只能在返回一个类型的时候，使用 trait 作为返回值类型，如果你既想返回 Tweet 也想返回 Article 是不行的。</p><p>如以下的代码就会报错</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn summarize(switch: bool) -&gt; impl Summary</span><br><span class="line">&#123;</span><br><span class="line">    if switch &#123;</span><br><span class="line">        Tweet&#123;</span><br><span class="line">            username: String::from(&quot;TwoSix&quot;),</span><br><span class="line">            content: String::from(&quot;Hello, world!&quot;),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Article&#123;</span><br><span class="line">            title: String::from(&quot;Hello&quot;),</span><br><span class="line">            location: String::from(&quot;World&quot;),</span><br><span class="line">            author: String::from(&quot;TwoSix&quot;),</span><br><span class="line">            content: String::from(&quot;This is a test&quot;),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="练手"><a href="#练手" class="headerlink" title="练手"></a>练手</h2><p>还记得我们之前在讲泛型的时候使用的查找最大值的例子吗，之前代码编译不通过，但现在的我们已经有办法修复它了。</p><p>先回顾以下这段代码</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T&#123;</span><br><span class="line">    let mut largest = list[0];</span><br><span class="line">    for &amp;item in list.iter() &#123;</span><br><span class="line">        if item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>报错的是 <code>&gt;</code> 号不能用于泛型<code>T</code>，而 <code>&gt;</code> 实际上是一个叫做 <code>PartialOrd</code> 的 trait，所以这段代码报错的核心是，不是每个类型都实现了 <code>PartialOrd</code>，所以我们可以给它加个 trait 约束。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T&#123;</span><br><span class="line">    let mut largest = list[0];</span><br><span class="line">    for &amp;item in list.iter() &#123;</span><br><span class="line">        if item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>因为 <code>PartialOrd</code> 是预导入模块，所以我们可以直接使用，而不需要 use。我们修改完后，这段代码出现了新的报错：<code>cannot move out of here | move occurs because list[_] has type T, which does not implement the Copy trait</code>；意思就是，不是每个类型都实现了 Copy trait，所以我们没有办法把泛型 T 列表内的元素赋值出来，解决也很简单，那就是再加个 Copy 约束即可。</p><p>以下这段代码，就能正确的编译并找到不同类型数组的最大值了：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T: PartialOrd+Copy&gt;(list: &amp;[T]) -&gt; T&#123;</span><br><span class="line">    let mut largest = list[0];</span><br><span class="line">    for &amp;item in list.iter() &#123;</span><br><span class="line">        if item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    let a = vec![1, 2, 3, 4, 5];</span><br><span class="line">    let b = vec![&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];</span><br><span class="line">    let largest_a = largest(&amp;a);</span><br><span class="line">    let largest_b = largest(&amp;b);</span><br><span class="line">    println!(&quot;The largest number is &#123;&#125;&quot;, largest_a);</span><br><span class="line">    println!(&quot;The largest char is &#123;&#125;&quot;, largest_b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>PS：</p><p>这里我有点迷惑，这难道不是对应赋值吗？什么类型不能赋值出来？我查了一下资料，大致得出的结论如下，不知道对不对：</p><p>翻译应该沾点锅，看了下原文的意思应该是：不是所有类型都有 Copy trait，这里的 Copy trait 指的是深拷贝，在浅拷贝的变量里，赋值操作应该是 move，而 move 则对应了所有权的转移，对于一个列表内的变量，我们把它所有权转移出来之后，但数组自己是不知道自己的元素所有权已经没有了，这不就出问题了？</p><p>所以最重要的原因还是在于这一句代码：<code>let mut largest = list[0];</code> 这里把<code>list[0]</code>的元素所有权移出来了，自然有问题。所以我把代码改成下面这个样子，多加了一些引用的使用，不转移所有权，也就不需要使用Copy约束了。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T&#123;</span><br><span class="line">    let mut largest = &amp;list[0];</span><br><span class="line">    for item in list.iter() &#123;</span><br><span class="line">        if item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></blockquote><h2 id="通过约束为指定类型实现方法"><a href="#通过约束为指定类型实现方法" class="headerlink" title="通过约束为指定类型实现方法"></a>通过约束为指定类型实现方法</h2><p>也就是当我们定义了一个泛型结构体时，可以让这个结构体内的一些方法只能让指定的类型调用。</p><p>例如：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::Display;</span><br><span class="line"></span><br><span class="line">struct Pair&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line">impl&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    fn new(x: T, y: T) -&gt; Self &#123;</span><br><span class="line">        Self &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T: PartialOrd+Display&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    fn cmp_display(&amp;self)&#123;</span><br><span class="line">        if self.x &gt;= self.y&#123;</span><br><span class="line">            println!(&quot;The largest member is x = &#123;&#125;&quot;, self.x);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(&quot;The largest member is y = &#123;&#125;&quot;, self.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    let pair = Pair::new(1, 2);</span><br><span class="line">    pair.cmp_display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里我们就规定了 <code>Pair</code> 结构体里只有存放的类型是同时实现了可以比较可以打印两个 trait 的类型，才能调用<code>cmp_display</code>这个方法。（注意 <code>Display</code> trait 不是预导入的，虽然是标准库，也要自己 use）</p><p>当然，基于此，自然也可以为结构体的指定类型实现 trait。</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">impl&lt;T:Display&gt; ToString for Pair&lt;T&gt; &#123;</span><br><span class="line">    fn to_string(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;x = &#123;&#125;, y = &#123;&#125;&quot;, self.x, self.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    let pair = Pair::new(1, 2);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, pair.to_string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>普通的泛型可以用来消除重复代码，也可以向编译器指明程序员希望这些类型拥有什么样的行为，而生命周期就是一种特殊的泛型，用来<strong>确保引用在我们使用的过程中一直有效</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在介绍生命周期前，我们需要介绍编译器是怎么检查因为超出作用域而导致的悬垂引用问题的。我们来看看以下这个例子</p><p><img lazyload src="/images/loading.svg" data-src="/images/image.png" alt="img"></p><p>这个例子中，我们定义了一个变量<code>r</code>，在下一个花括号中，我们定义了一个变量<code>x</code>，并把<code>x</code>的所有权借给<code>r</code>，但x的作用域只在这个花括号为止，超出了这个花括号之后所有权就被回收了，<code>r</code>也就成了悬垂引用。</p><p>右边的<code>&#39;a,&#39;b</code>就分别代表了r和x的生命周期，我们可以明显的看到，x的生命周期’b明显要比r的生命周期’a短，所以编译器就可以通过检查生命周期的长短来查找你可能的悬垂引用问题，进而提出报错。</p><p>那我们为什么要指定生命周期？让我们来写一段代码</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">    if x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个函数用于比较得到长度更长的字符串，因为不想只是比较以下就夺取所有权，所以使用引用的方式传入，也使用引用的方式返回。</p><p>不出意外，会有错误提示<code>missing lifetime specifier</code>，我们回顾以下编译器检查悬垂引用的方式，需要比较一下引用的生命周期长短，而在以上情况中，我们有一个分支判断，既可能返回x，也可能返回y，编译器不知道会返回x还是返回y，也不知道该比较哪个和哪个引用之间的长短，也就无法进行检查，进而报错，提示我们需要指定生命周期，明确一下引用之间的关系，方便编译器进行比较。</p><h2 id="标注生命周期"><a href="#标注生命周期" class="headerlink" title="标注生命周期"></a>标注生命周期</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>标注生命周期的语法很简单，和我们之前举例的命名一样，生命周期的命名以<code>&#39;</code>开头，如<code>&#39;a</code></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;i32 // 这是一个普通引用</span><br><span class="line">&amp;&#x27;a i32 // 这是一个生命周期为&#x27;a的引用</span><br><span class="line">&amp;&#x27;a mut i32 // 这是一个生命周期为&#x27;a的可变引用</span><br></pre></td></tr></table></figure></div><h3 id="函数中的生命周期标注"><a href="#函数中的生命周期标注" class="headerlink" title="函数中的生命周期标注"></a>函数中的生命周期标注</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">    if x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>可见，我们用类似定义泛型的方式，定义了一个生命周期，名为<code>&#39;a</code>，并且给后面的引用都指定了生命周期为<code>&#39;a</code>，也就是告诉编译器，这个函数里传入的引用必然都是相同的生命周期，放心比较！于是编译器就会选择一个引用，推导出实际的生命周期<code>&#39;a</code>，然后和函数外的实际拥有所有权的变量进行比较，然后发现外边的变量生命周期都比<code>&#39;a</code>长，最后得出结果，这段代码可以编译通过。</p><p>那x和y是两个不同的变量啊，这里编译器最终得到的生命周期’a究竟是什么地方的生命周期？</p><p>答案也很简单，就是x和y重叠部分的生命周期</p><div class="code-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(a.<span class="title function_ invoke__">as_str</span>(), b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如以上代码，<code>&#39;a</code>的长度等同于变量<code>b</code>的生命周期（a,b重叠部分，也就是取最短的一个就行），我们定义了返回的引用生命周期也是<code>&#39;a</code>，因此返回的<code>result</code>生命周期也应该是在<code>b</code>的生命周期范围内，这段代码里和<code>b</code>一起被回收，所以没有问题，编译通过。</p><p>错误示例如下，result变量的生命周期要长于b的生命周期，则无法通过编译：</p><div class="code-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(a.<span class="title function_ invoke__">as_str</span>(), b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="深入理解生命周期"><a href="#深入理解生命周期" class="headerlink" title="深入理解生命周期"></a>深入理解生命周期</h2><p>由上面我们可以知道，其实标注生命周期的作用就是为了方便编译器检查。</p><p>所以自然而然的，不需要参与检查的变量也就不是必须标注的了，如：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里我们规定直接返回x，所以编译器只会顺着第一个参数x进行检查，所以我们只标注了x的生命周期，不标注y也是可以编译通过的，因为y和返回值没有半毛钱关系。</p><p>其次，我们标注生命周期，只是向编译器声明了以下传入的引用的生命周期关系，<strong>并没有改变任意一方的生命周期</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn longest&lt;&#x27;a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">    let result = String::from(&quot;really long string&quot;);</span><br><span class="line">    result.as_str()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>例如这一段代码，我们给返回值声明了生命周期<code>&#39;a</code>，但返回值<code>result</code>是在函数内定义的，他也就只能活在这个函数里，并不是说我们给他声明了一个生命周期，他就能活到外面去了。</p><h2 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h2><p>一般情况下结构体都是存储自持有的变量，但实际上也可以存储引用，这时候就需要用到生命周期</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#x27;a&gt; &#123;</span><br><span class="line">    part: &amp;&#x27;a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);</span><br><span class="line">    let first_sentence = novel.split(&#x27;.&#x27;).next().expect(&quot;Could not find a &#x27;.&#x27;&quot;);</span><br><span class="line">    let i = ImportantExcerpt &#123; part: first_sentence &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>定义的语法也是类似即可。</p><h2 id="生命周期省略"><a href="#生命周期省略" class="headerlink" title="生命周期省略"></a>生命周期省略</h2><p>可以说，所有引用必然是需要有自己的生命周期的，但其实以前编写的很多函数都没有指明生命周期，也能传入引用，是为什么呢？</p><p>其实早期的Rust是所有引用都必须显示标注生命周期的，但随着慢慢的发展，Rust的团队发现有很多情况下，是能够使用编译器推导出返回值的生命周期的，重复的写生命周期有点烦，也就把这部分情况，写成了可省略的生命周期规则。</p><p>编译器检查生命周期的规则有以下三条：</p><ol><li>每一个引用的参数，都有自己的生命周期</li><li>当只存在一个输入的生命周期参数时，这个生命周期会被赋予给所有输出的生命周期参数</li><li>当拥有多个输入的生命周期参数时，若其中一个是<code>&amp;self</code>或<code>&amp;mut self</code>，<code>self</code>的生命周期会被赋予给所有输出的生命周期参数</li><li>若以上三条规则使用完毕，编译器仍然无法推导出所有生命周期，则报错，让用户指定。</li></ol><p>这些规则帮助我们省略了很多生命周期的编写。为了更好了理解这些规则，我们举一些例子看看。</p><p>例如这段代码：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn test(s: &amp;str)-&gt;&amp;str&#123;</span><br></pre></td></tr></table></figure></div><p>按照规则1，编译器先给所有输入参数赋予自己的生命周期</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn test&lt;&#x27;a&gt;(s: &amp;&#x27;a str)-&gt;&amp;str&#123;</span><br></pre></td></tr></table></figure></div><p>由于只有一个输入参数s，满足规则2，编译器把生命周期赋予给所有输出的参数</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn test&lt;&#x27;a&gt;(s: &amp;&#x27;a str)-&gt;&amp;&#x27;a str&#123;</span><br></pre></td></tr></table></figure></div><p>至此，编译器自己推导出了所有参数的生命周期，也就不用我们写了。</p><p>接着，我们再距离说明一下规则3</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#x27;a&gt; &#123;</span><br><span class="line">    part: &amp;&#x27;a str,</span><br><span class="line">&#125;</span><br><span class="line">impl &lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123;</span><br><span class="line">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">        self.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>impl &lt;&#39;a&gt; ImportantExcerpt&lt;&#39;a&gt;</code>这个声明语句中的生命周期声明不能省略（我也不知道为什么）</p><p>在方法<code>announce_and_return_part</code>中，编译器会首先按照规则1，赋予声明周期</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn announce_and_return_part(&amp;&#x27;a self, announcement: &amp;&#x27;b str) -&gt; &amp;str &#123;</span><br></pre></td></tr></table></figure></div><p>因为有两个参数，规则不生效</p><p>最后因为参数里有self，所以按照规则3，赋予输出参数self的声明周期</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn announce_and_return_part(&amp;&#x27;a self, announcement: &amp;&#x27;b str) -&gt; &amp;&#x27;a str &#123;</span><br></pre></td></tr></table></figure></div><p>这时候，所有生命周期也就推导完毕了，不需要手动指定，也可编译通过。</p><blockquote><p>如果不返回<code>self.part</code>，返回<code>announcement</code>一样会报错，但此时报错的提示是announcement的生命周期不一定比self长，而不是缺少生命周期声明，可见编译器确实给输出赋予了self的声明周期，并进行检查</p></blockquote><h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><p>一种特殊的生命周期，意味在整个程序的执行期中都可以存活</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s:&amp;&#x27;static str = &quot;I have a static lifetime.&quot;;</span><br></pre></td></tr></table></figure></div><p>但使用需要谨慎，1：你需要确保他确实可以在整个程序的生命周期存活；2：你确定它真的需要活这么长时间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后用一段代码，同时使用泛型、trait约束、生命周期</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::Display;</span><br><span class="line"></span><br><span class="line">fn longest_with_ann&lt;&#x27;a, T&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str, ann: T) -&gt; &amp;&#x27;a str</span><br><span class="line">    where T: Display</span><br><span class="line">&#123;</span><br><span class="line">    println!(&quot;Announcement! &#123;&#125;&quot;, ann);</span><br><span class="line">    if x.len() &gt; y.len()&#123;</span><br><span class="line">        x</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let string1 = String::from(&quot;abcd&quot;);</span><br><span class="line">    let string2 = &quot;xyz&quot;;</span><br><span class="line">    let result = longest_with_ann(string1.as_str(), string2, 123);</span><br><span class="line">    println!(&quot;The longest string is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>简单解释一下代码</p><ol><li>定义了一个声明周期<code>&#39;a</code>，用来声明传入的两个字符串x, y的生命周期，以及返回字符串的生命周期</li><li>定义了一个泛型<code>T</code></li><li>约束了泛型<code>T</code>只能是实现了<code>Display</code>这个trait的类型，方便后续直接使用<code>println!</code>输出</li></ol></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 【Rust 学习记录】10. 泛型、trait与生命周期</li><li><strong>作者:</strong> TwoSix</li><li><strong>创建于 :</strong> 2023-05-08 21:17:12</li><li><strong>更新于 :</strong> 2024-07-04 23:52:28</li><li><strong>链接:</strong> https://twosix.page/2023/05/08/【Rust-学习记录】10-泛型、trait与生命周期/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/Rust/">#Rust</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2023/05/09/%E3%80%90Rust-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%9111-%E7%BC%96%E5%86%99%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">【Rust 学习记录】11. 编写自动化测试</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2023/04/15/%E4%BD%BF%E7%94%A8Sphinx%E4%B8%BA%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E6%96%87%E6%A1%A3/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">使用Sphinx为你的项目快速构建文档</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">评论</div><div id="waline"></div><script type="module" data-swup-reload-script>import{init}from"/js/libs/waline.mjs";function loadWaline(){init({el:"#waline",serverURL:"https://waline.twosix.page",lang:"zh-CN",dark:'body[class~="dark-mode"]',reaction:!0,requiredMeta:["nick","mail"],emoji:["https://unpkg.com/@waline/emojis@1.2.0/bmoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],turnstileKey:"0x4AAAAAAAP-r44rmpEdcREN"})}"undefined"!=typeof swup?loadWaline():window.addEventListener("DOMContentLoaded",loadWaline)</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">目录</div><div class="page-title">【Rust 学习记录】10. 泛型、trait与生命周期</div><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-text">在函数定义中使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-text">在结构体定义中使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-text">在方法定义中使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-text">在枚举类型定义中使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-text">泛型的性能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#trait%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%85%B1%E4%BA%AB%E8%A1%8C%E4%B8%BA"><span class="nav-text">trait：定义共享行为</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89trait"><span class="nav-text">定义trait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0trait"><span class="nav-text">实现trait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0"><span class="nav-text">默认实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8Atrait%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-text">把trait作为参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#trait%E7%BA%A6%E6%9D%9F"><span class="nav-text">trait约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AAtrait%E7%BA%A6%E6%9D%9F"><span class="nav-text">多个trait约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96trait%E7%BA%A6%E6%9D%9F"><span class="nav-text">简化trait约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8Atrait%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-text">把trait作为函数返回值类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E6%89%8B"><span class="nav-text">练手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%BA%A6%E6%9D%9F%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-text">通过约束为指定类型实现方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E6%B3%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">标注生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8"><span class="nav-text">函数中的生命周期标注</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">深入理解生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">结构体中的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5"><span class="nav-text">生命周期省略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">静态生命周期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2024&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">TwoSix</a><p class="post-count space-x-0.5"><span>共撰写了 17 篇文章 </span><span>共 55.8k 字</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div class="icp-info my-1"><a target="_blank" rel="nofollow" href="https://icp.gov.moe/">萌ICP备20232266号</a></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script><a style="text-decoration:none;display:inline-flex;align-items:center;justify-content:center" href="https://travel.moe/go.html" title="异次元之旅-跃迁-我们一起去萌站成员的星球旅行吧！" target="_blank"><img src="https://travel.moe/images/icon/icon64.png" style="width:24px;height:24px;margin-right:8px">异次元之旅</a></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/pangu.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/pangu.js"></script></body></html>