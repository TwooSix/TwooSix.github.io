<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Blog"><meta name="author" content="TwoSix"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://registry.npmmirror.com" crossorigin><link rel="canonical" href="https://twosix.page/2023/05/09/【rust-学习记录】11-编写自动化测试/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="这一章讲的就是怎么在Rust编写单元测试代码，这一部分的思想不仅适用于Rust，在绝大多数语言都是有用武之地的  如何编写测试测试代码的构成构成通用测试代码通常包括三个部分  准备所需的数据或者前置状态 调用需要测试的代码 使用断言，判断运行结果是否和我们期望的一致  在Rust中，有专门用于编写测试代码的相关功能，包含test属性，测试宏，should_panic属性等等 在最简单的情况下，R"><meta property="og:type" content="article"><meta property="og:title" content="【Rust 学习记录】11. 编写自动化测试"><meta property="og:url" content="https://twosix.page/2023/05/09/%E3%80%90Rust-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%9111-%E7%BC%96%E5%86%99%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/index.html"><meta property="og:site_name" content="TwoSix的小木屋"><meta property="og:description" content="这一章讲的就是怎么在Rust编写单元测试代码，这一部分的思想不仅适用于Rust，在绝大多数语言都是有用武之地的  如何编写测试测试代码的构成构成通用测试代码通常包括三个部分  准备所需的数据或者前置状态 调用需要测试的代码 使用断言，判断运行结果是否和我们期望的一致  在Rust中，有专门用于编写测试代码的相关功能，包含test属性，测试宏，should_panic属性等等 在最简单的情况下，R"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-05-09T08:00:30.000Z"><meta property="article:modified_time" content="2024-07-04T15:52:28.391Z"><meta property="article:author" content="TwoSix"><meta property="article:tag" content="Rust"><meta name="twitter:card" content="summary"><link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico"><meta name="theme-color" content="#9d5da2"><link rel="shortcut icon" href="/images/logo.ico"><title>【Rust 学习记录】11. 编写自动化测试 | TwoSix的小木屋</title><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/fonts/Chillax/chillax.css"><script data-swup-reload-script defer src="https://umami.2626666.xyz/script.js" data-website-id="1febf3b2-6f24-4ac8-a6ff-458478feafb9"></script><meta name="baidu-site-verification" content="codeva-t9TDxWNwbp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/css/tailwind.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/fonts/Geist/geist.css"><script id="hexo-configurations">window.config={hostname:"twosix.page",root:"/",language:"zh-CN",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!0,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#9d5da2",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!1,custom_message:null},open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/background.webp",dark:"/images/background.webp"},title:"TwoSix的小木屋",subtitle:{text:["Hello World!"],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!0,style:"default",links:{github:"https://github.com/TwooSix",instagram:null,zhihu:null,twitter:null,email:null,"fa-solid fa-envelope":"mailto:ljj2288@gmail.com"},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"9.3.0"}},version:"2.8.0",navbar:{auto_hide:!0,color:{left:"#4f35a2",right:"#cbd0f6",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},"时间线":{path:"/archives",icon:"fa-regular fa-archive"},"追番列表":{path:"/bangumi",icon:"fa-regular fa-tv"},About:{path:"/about",icon:"fa-regular fa-user"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"info",announcement:null,show_on_mobile:!0,links:null},article_date_format:"auto",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/11/26 18:00:00"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/fontawesome/regular.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/fontawesome/sharp-solid.min.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="TwoSix的小木屋" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">TwoSix的小木屋</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-regular fa-archive fa-fw"></i> 时间线</a></li><li class="navbar-item"><a href="/bangumi"><i class="fa-regular fa-tv fa-fw"></i> 追番列表</a></li><li class="navbar-item"><a href="/about"><i class="fa-regular fa-user fa-fw"></i> 关于</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>时间线 </span><i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/bangumi"><span>追番列表 </span><i class="fa-regular fa-tv fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/about"><span>关于 </span><i class="fa-regular fa-user fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">4</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">2</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">【Rust 学习记录】11. 编写自动化测试</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/logo.webp"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">TwoSix</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2023-05-09 16:30</span> <span class="mobile">2023-05-09 16:30</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-07-04 23:52:28</span> <span class="mobile">2024-07-04 23:52:28</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/%E7%BC%96%E7%A8%8B-%E8%AF%AD%E8%A8%80/">编程/语言</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/Rust/">Rust</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>4.8k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>19 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><blockquote><p>这一章讲的就是怎么在Rust编写单元测试代码，这一部分的思想不仅适用于Rust，在绝大多数语言都是有用武之地的</p></blockquote><h1 id="如何编写测试"><a href="#如何编写测试" class="headerlink" title="如何编写测试"></a>如何编写测试</h1><h2 id="测试代码的构成"><a href="#测试代码的构成" class="headerlink" title="测试代码的构成"></a>测试代码的构成</h2><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>通用测试代码通常包括三个部分</p><ol><li>准备所需的数据或者前置状态</li><li>调用需要测试的代码</li><li>使用断言，判断运行结果是否和我们期望的一致</li></ol><p>在Rust中，有专门用于编写测试代码的相关功能，包含test属性，测试宏，should_panic属性等等</p><p>在最简单的情况下，Rust中的测试就是一个标注有<code>test</code>属性的函数。只需要将<code>#[test]</code>添加到函数的关键字<code>fn</code>上，就能使用<code>cargo test</code>命令来运行测试。</p><p>测试命令会构建一个可执行文件，调用所有标注了test的函数，生成相关报告。</p><blockquote><p>PS：</p><p><strong>属性</strong>是一种修饰代码的一种元数据，例如之前为了输出结构体时，加入的<code>#[derive(Debug)]</code>就是一个属性，声明属性后，会为下面的代码自动生成一些实现，如<code>#[derive(Debug)]</code>修饰结构体时，就会为结构体生成Debug trait的实现</p></blockquote><h3 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h3><p>接下来我们就试试怎么测试</p><p>首先新建一个名为adder的项目<code>cargo new adder --lib</code>(–lib指生成lib.rs文件)</p><p>可能是版本比较新，lib.rs里直接生成有了以下代码</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pub fn add(left: usize, right: usize) -&gt; usize &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_works() &#123;</span><br><span class="line">        let result = add(2, 2);</span><br><span class="line">        assert_eq!(result, 4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们先忽略一些没讲过的关键词，这段代码里我们定义了一个<code>it_works</code>函数，并标注为测试函数，然后使用断言判断<code>add</code>函数的结果是否正确的等于4。在了解了大概功能之后，我们直接运行测试看看</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cargo test</span><br><span class="line">   Compiling adder v0.1.0 (E:\Code\rust\adder)</span><br><span class="line">    Finished test [unoptimized + debuginfo] target(s) in 0.29s</span><br><span class="line">     Running unittests src\lib.rs (target\debug\deps\adder-0a86cd050490705e.exe)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure></div><p>对应的测试结果如上</p><ul><li>passed: 测试通过的函数数量，我们这里只有一个it_works函数，且测试通过，所以为1</li><li>failed: 测试失败的函数数量</li><li>ignored: 被标记为忽略的测试函数，后面会提</li><li>measured: Rust还提供了衡量函数性能的benchmark方法，不过编写书的时候似乎这部分还不完善，所以不会有讲解，想了解需要自行学习</li><li>filtered out：被过滤掉的测试函数</li><li>Doc-tests：文档测试，这是个很好用的特性，可以防止你在修改了函数之后，忘记修改自己的文档，保证文档能和实际代码同步。</li></ul><p>测试时，每一个测试函数都是运行在独立的线程里的，所以发生panic时并不会影响其他的测试，我们可以写一个错误的函数看看</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pub fn add(left: usize, right: usize) -&gt; usize &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn error() &#123;</span><br><span class="line">        let result = add(3, 2);</span><br><span class="line">        assert_eq!(result, 4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_works() &#123;</span><br><span class="line">        let result = add(2, 2);</span><br><span class="line">        assert_eq!(result, 4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cargo test</span><br><span class="line">   Compiling adder v0.1.0 (E:\Code\rust\adder)</span><br><span class="line">    Finished test [unoptimized + debuginfo] target(s) in 0.24s</span><br><span class="line">     Running unittests src\lib.rs (target\debug\deps\adder-0a86cd050490705e.exe)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line">test tests::error ... FAILED</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::error stdout ----</span><br><span class="line">thread &#x27;tests::error&#x27; panicked at &#x27;assertion failed: `(left == right)`</span><br><span class="line">  left: `5`,</span><br><span class="line"> right: `4`&#x27;, src\lib.rs:18:9</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::error</span><br><span class="line"></span><br><span class="line">test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `--lib`</span><br></pre></td></tr></table></figure></div><p>可以看见，error的panic并不影响it_works的测试通过。</p><h2 id="assert-宏"><a href="#assert-宏" class="headerlink" title="assert!宏"></a>assert!宏</h2><h3 id="assert"><a href="#assert" class="headerlink" title="assert!"></a>assert!</h3><p><code>assert!</code>宏主要的功能是用来确保某个值为<code>true</code>，所以常被用于测试中。如<code>a&gt;b</code>等场景，返回的是一个bool值，就完美的符合assert!的使用场景，可以使用assert!进行测试，例如</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pub fn cmp(a: i32, b: i32) -&gt; bool &#123;</span><br><span class="line">    if a&gt;b&#123;</span><br><span class="line">        true</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn cmp_test()&#123;</span><br><span class="line">        let result = cmp(3, 2);</span><br><span class="line">        assert!(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="assert-eq-和assert-ne"><a href="#assert-eq-和assert-ne" class="headerlink" title="assert_eq!和assert_ne!"></a>assert_eq!和assert_ne!</h3><p>那如果返回值不是bool值呢？前面也出现过了，我们可以使用<code>assert_eq!</code>或者<code>assert_ne!</code>来断言两个值是否相等。</p><p>eq则对应的只有相等才能通过断言，ne则对应的只有不相等才能通过断言，用例见上面的add测试即可。</p><p><strong>但是注意</strong>，assert_eq!和assert_ne!使用了<code>==</code>和<code>!=</code>来实现是否相等的判断，也就意味着，传入这两个宏的参数是必须实现了<code>PartialEq</code>这个trait的。同时，我们可见错误的输出中会打印出详细的不相等原因，也就是说它还同时需要实现了<code>Debug</code>宏帮助打印输出。一般绝大部分参数都是满足要求的，自定义的结构体时需要注意。</p><blockquote><p>之前提到过属性这个概念，会为你自动实现一些功能，实际上PartialEq和Debug作为可派生的宏，也内置了属性的实现，你只需要在自己定义的结构体上加上<code>#[derive(PartialEq, Debug)]</code>，就能自动帮你实现这两个宏</p></blockquote><h3 id="自定义错误提示代码"><a href="#自定义错误提示代码" class="headerlink" title="自定义错误提示代码"></a>自定义错误提示代码</h3><p>上面我们说到assert_eq是会有详细输出的，告诉你怎么不相等了，帮助你排除bug，但普通的assert!只判断布尔值，所以没办法有详细的输出，这时候我们可以定制一个输出，使得错误提示更人性化一点。</p><p>如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pub fn cmp(a: i32, b: i32) -&gt; bool &#123;</span><br><span class="line">    if a&gt;b&#123;</span><br><span class="line">        true</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn cmp_test()&#123;</span><br><span class="line">        let a = 2;</span><br><span class="line">        let b = 3;</span><br><span class="line">        let result = cmp(a, b);</span><br><span class="line">        assert!(result, &quot;&#123;&#125; is not bigger than &#123;&#125;&quot;, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>和一般不一样，我们不需要用什么格式化字符串的方法先格式化一个字符串，再传入这个字符串，断言支持直接使用格式化的语法。这段代码的输出如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">running 1 test</span><br><span class="line">thread &#x27;tests::cmp_test&#x27; panicked at &#x27;2 is not bigger than 3&#x27;, src\lib.rs:23:9</span><br><span class="line">stack backtrace:</span><br></pre></td></tr></table></figure></div><p>可见报错提示相对于单纯的panicked at更人性化了一些。</p><p>当然，自定义输出也支持在assert_eq和assert_ne里使用</p><h2 id="should-panic"><a href="#should-panic" class="headerlink" title="should_panic"></a>should_panic</h2><p>should_panic也是一个属性，用来测试代码是否能正确的在出错时发生panic。用例如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pub fn positive_num(a: i32) -&gt; i32 &#123;</span><br><span class="line">    if a &gt; 0 &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        panic!(&quot;&#123;&#125; is not positive&quot;, a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    #[should_panic]</span><br><span class="line">    fn pos_test()&#123;</span><br><span class="line">        let a = -1;</span><br><span class="line">        positive_num(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码用来检查一个数是否是正数，在不是时抛出panic，接下来我们使用<code>#[should_panic]</code>来检查程序是否正确的panic，这段代码运行测试通过没问题。</p><p>接下来我们修改一下a的值，让程序不抛出panic，看看会发生什么</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">running 1 test</span><br><span class="line">test tests::pos_test - should panic ... FAILED</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::pos_test stdout ----</span><br><span class="line">note: test did not panic as expected</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::pos_test</span><br><span class="line"></span><br><span class="line">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass `-p adder --lib`</span><br></pre></td></tr></table></figure></div><p>测试失败，告诉你pos_test没有按照预期发生panic。这个特性可以用来检查你的代码是否能正确的处理报错，发生panic以阻止程序进一步运行，产生不可预估的后果。</p><p>但是，单纯这么使用感觉有点含糊不清，因为程序发生panic的原因可能不是我们所预期的，假如其他一些我们不知道的原因抛出了panic，也会导致测试通过。所以我们可以添加一个可选参数<code>expected</code>，用来检查panic发生报错的输出信息里是否包含指定的文字。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#[test]</span><br><span class="line">#[should_panic(expected = &quot;positive&quot;)]</span><br><span class="line">fn pos_test()&#123;</span><br><span class="line">    let a = -1;</span><br><span class="line">    positive_num(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这时候，should_panic就会检查发生的panic输出的报错信息是否包含”positive”这个字符串，如果是，才会测试通过，输出如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">running 1 test</span><br><span class="line">thread &#x27;tests::pos_test&#x27; panicked at &#x27;-1 is not positive&#x27;, src\lib.rs:9:9</span><br><span class="line">stack backtrace:</span><br></pre></td></tr></table></figure></div><p>可见，输出中也包含了报错的信息，更人性化了。</p><h2 id="使用Result编写测试"><a href="#使用Result编写测试" class="headerlink" title="使用Result编写测试"></a>使用Result编写测试</h2><p>之前学习Result枚举的时候我们就知道了这东西是用来处理报错的，自然也就可以用来处理测试。使用时也很简单，我们只需要声明测试函数的返回值是Result，test命令就会自动根据Result的枚举结果来判断是否测试成功了。如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_works() -&gt; Result&lt;(), String&gt;&#123;</span><br><span class="line">        if 2+2 == 4 &#123;</span><br><span class="line">            Ok(())</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Err(String::from(&quot;two plus two does not equal four&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>使用Result编写测试函数的主要优势是可以使用问号表达式进行错误捕获，更方便我们去编写一些复杂的测试函数，可以让函数在任一时刻有错误被捕获到时，就返回报错。</p><p>问号表达式的使用可见<a href="https://twosix.page/archives/345">【Rust 学习记录】9. 错误处理</a>的？运算符部分，这里就不再写代码举例了（主要书上没例子，我也懒的写）</p><h1 id="控制测试的运行方式"><a href="#控制测试的运行方式" class="headerlink" title="控制测试的运行方式"></a>控制测试的运行方式</h1><p>这一部分主要是对cargo test命令的讲解，具体的运行方式，参数的使用等。</p><p>cargo test的参数统一需要写在<code>--</code>后面，也就是说你想要使用<code>--help</code>显示参数文档时，需要使用以下命令</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --help</span><br></pre></td></tr></table></figure></div><h2 id="并行或串行的执行代码"><a href="#并行或串行的执行代码" class="headerlink" title="并行或串行的执行代码"></a>并行或串行的执行代码</h2><p>默认情况下，测试是多线程并发执行的，这可以使测试更快速的完成，且相互之间不会影响结果。但如果测试间有相互依赖关系，则需要串行执行。例如两个测试用例同时在操作一个文件，一个测试在写内容，一个测试在读内容时，则容易导致测试结果不合预期。</p><p>我们可以使用<code>--test-threads=1</code>来指定测试的线程数为1，即可实现串行执行，当然，你想执行的更快也可以指定更多的线程</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --test-threads=1</span><br></pre></td></tr></table></figure></div><h2 id="显示函数的输出"><a href="#显示函数的输出" class="headerlink" title="显示函数的输出"></a>显示函数的输出</h2><p>默认情况下，test命令会捕获所有测试成功时的输出，也就是说，对于测试成功的函数，即使你使用了println!打印输出，你也无法在控制台看见你的输出，因为它被test命令捕获吞掉了。</p><p>如果你想要在控制台显示你的输出，只需要用<code>--nocapture</code>设置不捕获输出即可</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --nocapture</span><br></pre></td></tr></table></figure></div><h2 id="只运行部分特定名称的测试"><a href="#只运行部分特定名称的测试" class="headerlink" title="只运行部分特定名称的测试"></a>只运行部分特定名称的测试</h2><p>如果测试的函数越写越多，执行所有的测试可能很花时间，通常我们编写了一个新的功能并想进行测试的时候，我们只需要测试这一个功能就足够了，因此可以向test命令指定函数名称来进行测试。</p><p>如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fn add_two(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn add_test_1() &#123;</span><br><span class="line">        assert_eq!(add_two(1, 2), 3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn add_test_2() &#123;</span><br><span class="line">        assert_eq!(add_two(2, 2), 4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn one_hundred() &#123;</span><br><span class="line">        assert_eq!(100, 100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对于这段代码，我们只想测试<code>one_hundred</code>这个函数，只需要对test命令指定运行one_hundred即可</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test one_hundred</span><br></pre></td></tr></table></figure></div><p>输出如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">running 1 test</span><br><span class="line">test tests::one_hundred ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure></div><p>这里显示<code>2 filtered out</code>，代表有两个测试用例被我们过滤掉了。</p><p>当然，这个方法也并不是只能运行一个测试函数，也可以通过部分匹配的方法执行多个名称里包含相同字符串的测试函数，例如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cargo test add        </span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::add_test_1 ... ok</span><br><span class="line">test tests::add_test_2 ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure></div><p>我们使用<code>cargo test add</code>命令，则可以测试所有名字里带<code>add</code>的测试函数，忽略掉了one_hundred函数。</p><p>不过需要注意的是，这种方法一次只能使用一个参数进行匹配并测试，如果你想同时用多个规则匹配多类的测试函数，就需要用其他方法了。</p><h2 id="通过显示指定来忽略某些测试"><a href="#通过显示指定来忽略某些测试" class="headerlink" title="通过显示指定来忽略某些测试"></a>通过显示指定来忽略某些测试</h2><h3 id="忽略部分测试函数"><a href="#忽略部分测试函数" class="headerlink" title="忽略部分测试函数"></a>忽略部分测试函数</h3><p>当有部分测试函数执行特别耗时时，我们不想每次测试都执行这个函数，我们就可以通过<code>#[ignore]</code>属性来显示指定忽略这个测试函数。如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fn add_two(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn add_test_1() &#123;</span><br><span class="line">        assert_eq!(add_two(1, 2), 3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    #[ignore]</span><br><span class="line">    fn add_test_2() &#123;</span><br><span class="line">        assert_eq!(add_two(2, 2), 4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn one_hundred() &#123;</span><br><span class="line">        assert_eq!(100, 100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>此时我们直接执行<code>cargo test</code>，输出如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">running 3 tests</span><br><span class="line">test tests::add_test_2 ... ignored</span><br><span class="line">test tests::add_test_1 ... ok</span><br><span class="line">test tests::one_hundred ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 2 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br></pre></td></tr></table></figure></div><p>可见<code>add_test_2</code>函数被忽略不执行了，提示1 ignored。</p><h3 id="单独执行被忽略的测试函数"><a href="#单独执行被忽略的测试函数" class="headerlink" title="单独执行被忽略的测试函数"></a>单独执行被忽略的测试函数</h3><p>如果我们想单独执行这些被忽略的函数，则可以使用<code>--ignored</code>命令</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --ignored</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::add_test_2 ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure></div><p>可见，只有<code>add_test_2</code>被执行了。</p><h1 id="测试的组织结构"><a href="#测试的组织结构" class="headerlink" title="测试的组织结构"></a>测试的组织结构</h1><p>测试通常分为两类，单元测试和集成测试。单元测试小而专注，集中于测试一个私有接口或模块；集成测试则独立于代码库之外，正常的从外部调用公共接口，一次测试可能使用多个模块</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试的目的在于将一小段代码单独隔离开来，快速确定代码结果是否符合预期。一般来说，单元测试的代码<strong>和需要测试的代码存放在同一文件中</strong>。同时也约定俗成的在每个源代码文件里都会新建一个tests模块来存放测试函数，并使用cfg(test)来标注。</p><h3 id="测试模块和-cfg-test"><a href="#测试模块和-cfg-test" class="headerlink" title="测试模块和#[cfg(test)]"></a>测试模块和#[cfg(test)]</h3><p><code>#[cfg(test)]</code>旨在让Rust只在执行Cargo test命令的时候编译和运行这段代码，而在cargo build的时候剔除掉它们，只用于测试，节省编译时间与空间，使得我们可以更方便的把测试代码和源代码放在同一个文件里。（集成测试时一般不需要标注，因为集成测试一般是独立的一个文件）</p><p>我们之前编写的测试模块就使用了这个属性</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_works() &#123;</span><br><span class="line">        let result = add(2, 2);</span><br><span class="line">        assert_eq!(result, 4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="测试私有函数"><a href="#测试私有函数" class="headerlink" title="测试私有函数"></a>测试私有函数</h3><p>是不是应该测试私有函数一直有争议，不管你觉得要不要，但Rust提供了方法供你方便的测试。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn add(left: usize, right: usize) -&gt; usize &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_works() &#123;</span><br><span class="line">        let result = add(2, 2);</span><br><span class="line">        assert_eq!(result, 4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以上代码中的add没有标注pub关键字，也就是私有的，但因为Rust的测试代码本身也属于Rust代码，所以可以通过use的方法把私有的函数引入当前作用域来测试，也就是对应的代码里的<code>use super::*;</code></p><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>集成测试通常是新建一个tests目录，只调用对外公开的那部分接口。</p><h3 id="tests目录"><a href="#tests目录" class="headerlink" title="tests目录"></a>tests目录</h3><p>tests目录需要和src文件夹并列，Cargo会自动在这个目录下面寻找测试文件。</p><p>现在，我们新建一个<code>tests/integration_test.rs</code>文件，保留之前的lib.rs代码(add函数如果改了私有记得改回公有)，并编写测试代码。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use adder;</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">fn add_two() &#123;</span><br><span class="line">    assert_eq!(adder::add(2, 2), 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>集成测试就不需要<code>#[cfg(test)]</code>了，Rust有单独为tests目录做处理，不会build这个目录下的文件。</p><p>接下来，我们再执行以下Cargo test，看看输出</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cargo test</span><br><span class="line">   Compiling adder v0.1.0 (E:\Code\rust\adder)</span><br><span class="line">    Finished test [unoptimized + debuginfo] target(s) in 0.32s</span><br><span class="line">     Running unittests src\lib.rs (target\debug\deps\adder-0a86cd050490705e.exe)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests\integration_test.rs (target\debug\deps\integration_test-57f19c149db40d76.exe)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test add_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure></div><p>我们可以看到输出里</p><ol><li>先输出了单元测试的结果，<code>test tests::it_works … ok</code>，每行输出一个单元测试结果</li><li>再输出集成测试的结果，<code>Running tests\integration_test.rs</code>，表示正在测试哪个文件的测试模块，后续跟着这个文件的测试结果</li><li>最后是文档测试</li></ol><p>当编写的测试代码越多，输出也就会越多越杂，所以我们也可以使用<code>--test</code>参数指定集成测试的文件名，单独进行测试。如：<code>cargo test --test integration_test</code></p><h3 id="在集成测试中使用子模块"><a href="#在集成测试中使用子模块" class="headerlink" title="在集成测试中使用子模块"></a>在集成测试中使用子模块</h3><p>测试模块也和普通模块差不多，可以把函数分解到不同文件不同子目录里，当我们需要测试内容越来越多的时候，就会需要这么做。</p><p>但因为测试的特殊性，rust会把每个集成测试的文件编译成独立的包来隔离作用域，模拟用户实际的使用环境，这就意味着我们以前在src目录下管理文件的方法并不完全适用于tests目录了。</p><p>例如，我们需要编写一个common.rs文件，并且编写一个setup函数，这个函数将会用在多个不同的测试文件里使用，如</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub fn setup()&#123;</span><br><span class="line">    // 一些测试所需要初始化的数据</span><br><span class="line">    a = 1;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们执行cargo test时会有以下输出：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     Running tests\common.rs (target\debug\deps\common-15055e88a26e37ec.exe)</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure></div><p>可以发现，即便我们没有在common.rs里写任何测试函数，它依旧会将它作为测试文件执行，并输出无意义的running 0 tests。这明显不是我们所希望的，那如何解决呢？</p><p>我们可以使用mod.rs文件，把common.rs的文件内容移到tests&#x2F;common&#x2F;mod.rs里面，这样的意思是让Rust把common视作一个模块，而不是集成测试文件。</p><p>于是，我们就可以通过mod关键字引入common模块并使用其中的函数，例如</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// tests/integration_test.rs</span><br><span class="line">use adder;</span><br><span class="line"></span><br><span class="line">mod common;</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">fn add_two() &#123;</span><br><span class="line">    common::setup();</span><br><span class="line">    assert_eq!(adder::add(2, 2), 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>此时再运行cargo test，就不会出现common相关的测试输出了。</p><h3 id="二进制包的集成测试"><a href="#二进制包的集成测试" class="headerlink" title="二进制包的集成测试"></a>二进制包的集成测试</h3><p>如果我们的项目只有src&#x2F;main.rs而没有src&#x2F;lib.rs的话，是没有办法在tests中进行集成测试的，因为只有把代码用lib.rs文件指定为一个代码包crate，才能把函数暴露给其他包来使用，而main.rs对应的是二进制包，只能单独执行自己。</p><p>所以Rust的二进制项目通常会把逻辑编写在src&#x2F;lib.rs里，main.rs只对lib.rs的内容进行简单的调用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>没什么好总结的，下一章写项目去了。</p></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 【Rust 学习记录】11. 编写自动化测试</li><li><strong>作者:</strong> TwoSix</li><li><strong>创建于 :</strong> 2023-05-09 16:00:30</li><li><strong>更新于 :</strong> 2024-07-04 23:52:28</li><li><strong>链接:</strong> https://twosix.page/2023/05/09/【Rust-学习记录】11-编写自动化测试/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/Rust/">#Rust</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2023/05/12/%E3%80%90Rust-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%9112-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">【Rust 学习记录】12. 编写一个命令行程序</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2023/05/08/%E3%80%90Rust-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%9110-%E6%B3%9B%E5%9E%8B%E3%80%81trait%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">【Rust 学习记录】10. 泛型、trait与生命周期</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">评论</div><div id="waline"></div><script type="module" data-swup-reload-script>import{init}from"/js/libs/waline.mjs";function loadWaline(){init({el:"#waline",serverURL:"https://waline.twosix.page",lang:"zh-CN",dark:'body[class~="dark-mode"]',reaction:!0,requiredMeta:["nick","mail"],emoji:["https://unpkg.com/@waline/emojis@1.2.0/bmoji","https://unpkg.com/@waline/emojis@1.2.0/tieba"],turnstileKey:"0x4AAAAAAAP-r44rmpEdcREN"})}"undefined"!=typeof swup?loadWaline():window.addEventListener("DOMContentLoaded",loadWaline)</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">目录</div><div class="page-title">【Rust 学习记录】11. 编写自动化测试</div><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95"><span class="nav-text">如何编写测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9E%84%E6%88%90"><span class="nav-text">测试代码的构成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E6%88%90"><span class="nav-text">构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95"><span class="nav-text">初次尝试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#assert-%E5%AE%8F"><span class="nav-text">assert!宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#assert"><span class="nav-text">assert!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assert-eq-%E5%92%8Cassert-ne"><span class="nav-text">assert_eq!和assert_ne!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%E4%BB%A3%E7%A0%81"><span class="nav-text">自定义错误提示代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#should-panic"><span class="nav-text">should_panic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Result%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95"><span class="nav-text">使用Result编写测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-text">控制测试的运行方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%88%96%E4%B8%B2%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="nav-text">并行或串行的执行代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-text">显示函数的输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AA%E8%BF%90%E8%A1%8C%E9%83%A8%E5%88%86%E7%89%B9%E5%AE%9A%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">只运行部分特定名称的测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E6%9D%A5%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%B5%8B%E8%AF%95"><span class="nav-text">通过显示指定来忽略某些测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E9%83%A8%E5%88%86%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="nav-text">忽略部分测试函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%8B%AC%E6%89%A7%E8%A1%8C%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="nav-text">单独执行被忽略的测试函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="nav-text">测试的组织结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9D%97%E5%92%8C-cfg-test"><span class="nav-text">测试模块和#[cfg(test)]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%A7%81%E6%9C%89%E5%87%BD%E6%95%B0"><span class="nav-text">测试私有函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="nav-text">集成测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tests%E7%9B%AE%E5%BD%95"><span class="nav-text">tests目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%90%E6%A8%A1%E5%9D%97"><span class="nav-text">在集成测试中使用子模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="nav-text">二进制包的集成测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2024&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">TwoSix</a><p class="post-count space-x-0.5"><span>共撰写了 17 篇文章 </span><span>共 55.8k 字</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.0</a></span></div><div class="icp-info my-1"><a target="_blank" rel="nofollow" href="https://icp.gov.moe/">萌ICP备20232266号</a></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script><a style="text-decoration:none;display:inline-flex;align-items:center;justify-content:center" href="https://travel.moe/go.html" title="异次元之旅-跃迁-我们一起去萌站成员的星球旅行吧！" target="_blank"><img src="https://travel.moe/images/icon/icon64.png" style="width:24px;height:24px;margin-right:8px">异次元之旅</a></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/Swup.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/SwupSlideTheme.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/SwupScriptsPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/SwupProgressPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/SwupScrollPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/tools/imageViewer.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/utils.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/main.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/layouts/navbarShrink.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/tools/scrollTopBottom.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/tools/lightDarkSwitch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/layouts/categoryList.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/tools/localSearch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/tools/codeBlock.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/layouts/lazyload.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/tools/runtime.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/odometer.min.js"></script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/assets/odometer-theme-minimal.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/Typed.min.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/plugins/typed.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/anime.min.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/plugins/tabs.js" data-swup-reload-script></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/moment-with-locales.min.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/layouts/essays.js" data-swup-reload-script></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/libs/pangu.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.0/files/source/build/js/plugins/pangu.js"></script></body></html>